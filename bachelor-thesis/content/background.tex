\chapter{Background}

\section{Containerization Software}

\todo[inline]{\href{https://hackernoon.com/democratization-of-container-technologies-95cbbfaee08d}{Democratization of Container Technologies}}
\todo[inline]{\href{https://blog.aquasec.com/a-brief-history-of-containers-from-1970s-chroot-to-docker-2016}{A Brief History of Containers: From the 1970s to 2017}}

Containerization software is used to isolate software into packages (called containers). These containers only contain the necessary files for specific software to be run. Other files, libraries and binaries are shared between the host operating system (the system running the container). This allows developers to create lightweight software packages containing only the necessary dependencies.

\hfill

This is great for rapid development of software, because every small change can quickly be packaged into a container.

Containers also make it possible to run multiple versions of the same software on one host. Each container can contain a specific version and all the containers run on the same host. Because the containers are isolated from each other, their incompatible dependencies are not a problem.

\hfill

This has made containerization a very popular concept in developing and running software.

\subsubsection{Virtualization}

Virtualization is an older technique used to isolate software. In virtualization, a whole system is simulated in top of the host (called the Hypervisor). This new virtual machine is called a guest. The guest and the host do not share any system resources. This has some advantages. For example, it allows running a completely different system as guest (e.g. Windows guest run on a Linux host).

\hfill

Because containerization software shares many resources with the host, it is a lot faster and more flexible than virtualization. Where virtualization needs to start a whole new operating system, containerization only needs to start a single process.

\hfill

Where virtulization can and is used as a security layer, because it truly isolates the host and guest resources. Containerization should not be used as a security layer, because containers might be able to access sensitive resources that are shared between the host and the container. This makes containerization a lot more dangerous from a security perspective.

\section{Docker}
\todo[inline]{Docker is not a security model}
\todo[inline]{Docker on Windows}
\todo[inline]{Research: Secure Computing Mode Profiles}
\todo[inline]{Layers}
\todo[inline]{Docker Engine}
\todo[inline]{\href{https://itnext.io/chroot-cgroups-and-namespaces-an-overview-37124d995e3d}{chroot, cgroups and namespaces}}
\todo[inline]{\href{https://www.secura.com/blog-hacklu2018-docker-security}{Docker, A brief history and security considerations for modern environments}}

\hfill

The concept of containerization has been around a long time, but it only gained traction as serious way to package, distribute and run software in the last few years. This is mostly because of Docker.

\hfill

Docker was released in 2013 and it did not only offer a containerization platform, but also a way to distribute the containers. This allows developers and companies to create packages that are much more easily run.

\hfill

For example, someone that wants to run an instance of Wordpress (a very popular CMS), does not need to install all the Wordpress dependencies. They only need to download and run the Docker container.
Similarly, if they want to move the Wordpress instance from one host to the other, they just have to copy over the files and run the Docker image on the new machine.

\subsubsection{Docker Concepts}
Docker is based on three concepts: Docker images, Docker containers and \lstinline{Dockerfile}s.

\hfill

A Docker image is packaged software. It is a distributable file consisting of image layers.

\hfill

A container is an instance of a Docker Image. If you run software packaged as a Docker image, you create a container based on that image. If you want to run two instances of the same Docker image, you can create two containers.

\hfill

A \lstinline{Dockerfile} describes what a Docker image is made of. It describes the steps to create the image. Lets look at a very simple example:

\hfill

\begin{lstlisting}[caption={Very Basic \lstinline{Dockerfile}},label={dockerfile:simple},captionpos=b]
FROM alpine:latest
LABEL maintainer="Joren Vrancken"
CMD ["echo", "Hello World"]
\end{lstlisting}

\hfill

These three instructions tell the Docker engine how to create a new Docker image.

\begin{enumerate}
    \item The \lstinline{FROM} instruction tells the Docker engine what to base the new Docker image on. Instead of creating an image from scratch (a blank image), we use an already existing image as our basis.

    \item The \lstinline{LABEL} instruction sets a key value pair for the image. There can be multiple LABEL instructions. These key value pairs get packaged and distributed with the image.

    \item The \lstinline{CMD} instruction sets the default command that should be run and which arguments should be passed to it.
\end{enumerate}

The full instructionset can be found in the \lstinline{Dockerfile} reference\footnote{\url{https://docs.docker.com/engine/reference/builder/}}

\hfill

We can use this to create a new image and container from that image.
\begin{lstlisting}[caption={Creating a Docker container from a \lstinline{Dockerfile}},label={docker:container},captionpos=b]
$ docker build -t thesis-hello-world .
$ docker run --rm --name=thesis-hello-world-container thesis-hello-world
\end{lstlisting}

We first create a Docker image (called \lstinline{thesis-hello-world}) using the \lstinline{docker build} command and then create and start a new container (called \lstinline{thesis-hello-world-container}) from that image.

\subsubsection{Data Persistence}

\subsubsection{Networking}
\todo[inline]{iptables}
\todo[inline]{\url{https://github.com/docker/libnetwork/blob/master/docs/design.md}}

When a Docker container is created Docker creates a network sandbox for that container and (by default) connects it to an internal bridge network. This gives the container its own networking resourcessuch as a IPv4 address\footnote{IPv6 support is not enabled by default.}, routes and DNS entries. All outgoing traffic is routed through a bridge interface (by default).

\hfill

Incoming traffic is possible by routing traffic for specific ports from the host to the container.
Specifying which ports on the host are routed to which ports on the container is done when a container is created.

If we, for example, want to expose port \lstinline{80} to the Docker image created from the \hyperref[dockerfile:simple]{first \lstinline{Dockerfile}} we can execute the following commands.

\hfill

\begin{lstlisting}[caption={Creating a Docker container with exposed port},label={docker:publish},captionpos=b]
$ docker build -t thesis-hello-world .
$ docker run --rm --publish 8000:80 --name=thesis-hello-world-container thesis-hello-world
\end{lstlisting}

\hfill

We first create a Docker image using the \lstinline{Dockerfile} and then create (and start) a container from that image. We ``publish'' port \lstinline{8000} on the host to port \lstinline{80} of the container. This means that, while the container is running, all traffic from port \lstinline{8000} on the host is routed to port \lstinline{80} of the container.


\subsubsection{Docker internals}
\todo[inline]{\href{https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504}{Demystifying Containers Part I Kernel Space}}
\todo[inline]{\href{https://medium.com/@saschagrunert/demystifying-containers-part-ii-container-runtimes-e363aa378f25}{Demystifying Containers Part II Container Runtimes}}
\todo[inline]{\href{https://medium.com/@saschagrunert/demystifying-containers-part-iii-container-images-244865de6fef}{Demystifying Containers Part III Container Images}}

\subsection{docker-compose}
\todo[inline]{Secrets in docker-compose can be easily found, even without docker group permissions}

\subsection{Registries}
\todo[inline]{Official images not always standard images}

Docker images are distributable through so called registries. A registry is a server (that anybody can host), that stores Docker images. When a client does not have a Docker image that it needs, it can contact a registry to download that image.

\hfill

The most popular (and public) registry is Docker Hub, which is run by company that develops Docker.
Anybody can create a Docker Hub account and start creating images that anybody can download. Docker Hub also provides default images for popular software.

\section{Penetration Testing}
\subsection{Methodology Secura}

\section{CIS Benchmarks}
\todo[inline]{\url{https://docs.docker.com/compliance/cis/docker_ce/}}
The Center for Internet Security (or CIS for short) is a non-profit organization that provides best practice solutions for digital security. For example, they provide security hardened virtual machine images that are configured for optimal security.

\hfill

The CIS Benchmarks are guidelines and best practices on security on many different types of software. These guidelines are freely available for anyone and can be found on their site\footnote{\url{https://www.cisecurity.org/cis-benchmarks/}}.

\hfill

They also provide guidelines on Docker\cite{cis}. The latest version of the benchmarks (1.2.0) contain 115 guidelines. These are sorted by topic (e.g. Docker daemon and configuration files). In \hyperref[appendix:a]{the appendix} you will find an example CIS benchmark taken from the latest CIS benchmarks.

\section{Related Work}
