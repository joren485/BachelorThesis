\section{Docker}
\todo[inline]{Docker on Windows}
\todo[inline]{Research: Secure Computing Mode Profiles}

\hfill

The concept of containerization has been around a long time, but it only gained traction as serious way to package, distribute and run software in the last few years. This is mostly because of Docker.

\hfill

Docker was released in 2013 and it did not only offer a containerization platform, but also a way to distribute the containers. This allows developers and companies to create packages that are much more easily run.

\hfill

For example, someone that wants to run an instance of Wordpress\footnote{A very popular content management system to build websites with.}, does not need to install all the Wordpress dependencies. They only need to download the Docker image that the Wordpress developers created.
Similarly, if they want to move the Wordpress instance from one host to the other, they just have to copy over their database and run the Docker image on the new host. Even if the new host is a completely different operating system.

\subsection{Docker Concepts}
Docker is based on four concepts: Docker daemon, Docker images, Docker containers and \lstinline{Dockerfile}s.

\subsubsection{Docker daemon}
The daemon is a service that runs on the host machine. It manages all things related to Docker on that machine. For example if the user wants to build an image or a container needs to restart the docker daemon. It is good to note that, because everything related to Docker is handled by the daemon and Docker has access to all resources of the host, having access to Docker should be viewed as equivalent to having \lstinline{root} access to the host\footnote{\href{https://docs.docker.com/engine/security/security/\#docker-daemon-attack-surface}{Docker daemon attack surface}}.

\subsubsection{Docker images}
A Docker image is packaged software. It is a distributable set of layers. The first layer describes the base of the image. This is either an existing image or nothing (referred to as \lstinline{scratch}). Each layer on top of that is a change to the layer before. For example, if you add a file or run an command it adds a new layer.

\subsubsection{Docker containers}
A container is an instance of a Docker Image. If you run software packaged as a Docker image, you create a container based on that image. If you want to run two instances of the same Docker image, you can create two containers.

\subsubsection{\lstinline{Dockerfile}s}
A \lstinline{Dockerfile} describes what a Docker image is made of. It describes the steps to build the image. Lets look at a very simple example:

\begin{lstlisting}[caption={Very Basic \lstinline{Dockerfile}},label={dockerfile:simple},captionpos=b]
FROM alpine:latest
LABEL maintainer="Joren Vrancken"
CMD ["echo", "Hello World"]
\end{lstlisting}

These three instructions tell the Docker engine how to create a new Docker image.
The full instructionset can be found in the \lstinline{Dockerfile} reference\footnote{\url{https://docs.docker.com/engine/reference/builder/}}

\begin{enumerate}
    \item The \lstinline{FROM} instruction tells the Docker engine what to base the new Docker image on. Instead of creating an image from scratch (a blank image), we use an already existing image as our basis.

    \item The \lstinline{LABEL} instruction sets a key value pair for the image. There can be multiple LABEL instructions. These key value pairs get packaged and distributed with the image.

    \item The \lstinline{CMD} instruction sets the default command that should be run and which arguments should be passed to it.
\end{enumerate}

We can use this to create a new image and container from that image.
\begin{lstlisting}[caption={Creating a Docker container from a \lstinline{Dockerfile}},label={docker:container},captionpos=b]
$ docker build -t thesis-hello-world .
$ docker run --rm --name=thesis-hello-world-container thesis-hello-world
\end{lstlisting}

We first create a Docker image (called \lstinline{thesis-hello-world}) using the \lstinline{docker build} command and then create and start a new container (called \lstinline{thesis-hello-world-container}) from that image.

\subsubsection{Data Persistence}
Without additional configuration, a Docker container does not have persistence storage. Its storage is maintained when the container is stopped, but not when the container is removed.

\subsubsection{Networking}
\todo[inline]{iptables}
\todo[inline]{\url{https://github.com/docker/libnetwork/blob/master/docs/design.md}}

When a Docker container is created Docker creates a network sandbox for that container and (by default) connects it to an internal bridge network. This gives the container its own networking resources such as a IPv4 address\footnote{IPv6 support is not enabled by default.}, routes and DNS entries. All outgoing traffic is routed through a bridge interface (by default).

\hfill

Incoming traffic is possible by routing traffic for specific ports from the host to the container.
Specifying which ports on the host are routed to which ports on the container is done when a container is created. If we, for example, want to expose port \lstinline{80} to the Docker image created from the \hyperref[dockerfile:simple]{first \lstinline{Dockerfile}} we can execute the following commands.

\begin{lstlisting}[caption={Creating a Docker container with exposed port},label={docker:publish},captionpos=b]
$ docker build -t thesis-hello-world .
$ docker run --rm --publish 8000:80 --name=thesis-hello-world-container thesis-hello-world
\end{lstlisting}

The first command creates a Docker image using the \lstinline{Dockerfile} and we then create (and start) a container from that image. We ``publish'' port \lstinline{8000} on the host to port \lstinline{80} of the container. This means that, while the container is running, all traffic from port \lstinline{8000} on the host is routed to port \lstinline{80} of the container.

\subsubsection{Docker internals}
\todo[inline]{Add more detail}

A Docker container actually is a combination of multiple features within the Linux kernel. The main features are \lstinline{namespaces}, \lstinline{cgroups} and \lstinline{OverlayFS}.

\hfill

\lstinline{namespaces} are a way to isolate resources from processes. For example, if we add a process to a process namespace, it can only see the processes in that namespace. This allows processes to be completely isolated from each other. When the Docker daemon creates a new container, it creates new namespaces for the process that runs in that container. That way the container cannot view any of the processes, network interfaces and mount points of the host.

\hfill

\lstinline{cgroups} are a way to limit resources (e.g.\ CPU and RAM usage) to (groups of) processes and to monitor the usage of those processes.

\hfill

\lstinline{OverlayFS} is a file system that allows combining multiple directories and show them as if they are one. This is used to show the multiple layers in an Docker image as a single root directory.


\subsection{docker-compose}
\lstinline{docker-compose} is a wrapper around Docker that can be used to specify Docker container runtime configurations in files (called \lstinline{docker-compose.yaml}). These files remove the need to execute Docker commands with the correct arguments in the correct order. You have to specify the necessary arguments only once in the \lstinline{docker-compose.yaml} file.

\hfill

This is an advanced example of an \lstinline{docker-compose.yaml} file similar to configuration that I have used in a production environment. A lot of the time creating Docker containers in production environments, they need to have a lot of extra runtime configuration (e.g.\ environment variables, ports and dependencies on other containers). Specifying everything in a single file simplifies the runtime configuration process.
\begin{lstlisting}[caption={Example \lstinline{docker-compose.yaml}},label={docker:composefile},captionpos=b]
---
version: "3"

services:
  postgres:
    image: "postgres:10.5"
    restart: "always"
    environment:
      PGDATA: "/var/lib/postgresql/data/pgdata"
    volumes:
      - "/dir/data/:/var/lib/postgresql/data/"

  nextcloud:
    image: "nextcloud:17-fpm"
    restart: "always"
    ports:
      - "127.0.0.1:9000:9000"
    depends_on:
      - "postgres"
    environment:
      POSTGRES_DB: "database"
      POSTGRES_USER: "user"
      POSTGRES_PASSWORD: "password"
      POSTGRES_HOST: "postgres"
    volumes:
      - "/dir/www/:/var/www/html/"
\end{lstlisting}

This, however, also shows a security risk. A lot of the information that is passed to the containers is sensitive (e.g.\ the database password). That information is saved to disk. If the permissions of that file are not set correctly, an attacker could access the sensitive information.

\subsection{Registries}
\todo[inline]{Official images not always standard images}

Docker images are distributable through so called registries. A registry is a server (that anybody can host), that stores Docker images. When a client does not have a Docker image that it needs, it can contact a registry to download that image.

\hfill

The most popular (and public) registry is Docker Hub, which is run by the same company that develops Docker.
Anybody can create a Docker Hub account and start creating images that anybody can download. Docker Hub also provides default images for popular software.
